# http_request
Сделал 2 варианта использования:
1. В виде очереди: запус выполнятеся через команду app:execute-request-from-queue. Берется первый подходящий запрос и выполняется, при неудачном выполнение меняется время(параметр в services.yaml) следующего выполнения. После n-ого количества неудач статус ставится ERROR 
2. Выполнять определенный запрос:  запус выполнятеся через команду app:execute-request <requestId>. При неудачном выполнении повторно выполняется через секунду(константа в классе, можно сделать как параметр в service.yaml). Количество выполнений задается.
  
  Классы:
    1. RequestJobList - класс, который отвечает за работу с листом заданией. Условно абстактная оболочка для репозитория где можно добавить логирование и т.д. чего нельзя сделать в репозитории.
    2. RequestHandlerInterface - интерфейс отвечает за обработку запроса, устанавливет прокси, если нужно. Работает с объктом RequestItem. Реализует его класс RequestHandler.
    3. RequestItem - абстрактный класс передачи данных(DTO. (Нарушил принципе S и сам паттерн, так как считаю удобно сразу из объекта создавать свой экземпляр, а не делать для этого, условно, фабрику). Розширяя этот класс можно сделать объекты для работы с разными типами запрос и разными опциями.
    4. RequestItemFactory - фабрика для создания объекта RequestItem учитывая метод запроса.
    5. ResponseWriterInterface - интерфейс для обработки ответов от сервера и записи ответа в БД. Работает с entity Response. Реализует его класс ResponseWriter, который записывает ответ в БД.
    6. ProxyList - интерфейс для работы с прокси.  Реализует его класс DBProxyList - класс для работы с проксями в БД. 
