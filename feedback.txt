
Я разделил оценку по трем направлениям:
- знания symfony
- дизайн кода
- подход к решению задачи

По symfony вопрсов почти нет, видно что работал с фрейворком.

По дизайну кода и решению задачи есть вопросы:

- Логика приложения размазана по классам. Нет разделения по слоям. Например в командах содержится код обработки job. Почему не вынести в сервисы? 

- Почему две команды для обработки запроса и при этом нет команды на обработку всех запросов. Почему не сделать одну команду, а вариации ее применения разделить с помощью аргументов команды? 

- sleep(self::REQUEST_INTERVAL) вот это блокирует выполнение. Если увеличить проверку раз в час процесс будет висеть час. И что произойдет если пошлют ему сигнал завершения? Тут либо по прону либо через очереди делать.

- В репозитории метод getRandomProxy() загружает ВСЕ прокси и выбирает один случайный. А если их будет много?

- У прокси может быть аторизация и они могут быть разных типов (http, socks)

- Реализация RequestItem - связка абстрактного класса, фабрики и статических методов. Лучше применить  паттерн Стратегия. С прокси кстати тоже

- В некоторый местах есть обработка исключений, в некоторый нет, но обрабатывается возврат ошибок. Тоесть разный подход к обработке ошибок и не все ошибки учитываются. 

- Статические методы образуют сильную связь между классами. Это сложно рефакторить и очень сложно покрывать тестами.

- DBProxyList::getRandomProxy() возвращает Proxy, но DBProxyList::getProxyList() возвращает массив строк, почему не массив Proxy? И снова загружаются все прокси.

- Response::setData() принимает массив, в бд хнанится как json. А если будут например бинарные данные в ответе? Еще не оптимально будет хранение этих данных в бд, тело ответа может быть большим и при этом не у каждого ответа это тело будет. Обычно выносят в отдельную таблицу.




В общем хотелось бы видеть какой-то "опытный подход" к решению задачи с частыми запросами к внешнему сервису и их обработкой, это довольно частая задача для бекенда. Половина моих коментариев отновится к "потом это нужно поддерживать еще", так что в реальной задаче пришлось бы переделывать.

